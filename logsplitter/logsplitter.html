<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:_mdnsresponder@jackson.apple.com" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#EXAMPLES">EXAMPLES</a></li>
  <li><a href="#PERFORMANCE">PERFORMANCE</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<pre><code> logsplitter.pl - stdout rotation script. </code></pre>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> some_program 2&gt;&amp;1 | perl logsplitter.pl -name logName [options]

 where:
 -name          log name, but without extension (provided value or default &#39;log&#39; will be added). This parameter is mandatory,

 -dir           destination directory for log file. Default is current directory,
 -extension     log extension. Default is &#39;log&#39;,
 -rotateBySize  rotation done by line or byte count. Default is bytes,
 -limit         number of lines or bytes in single log file. Default values are 100 k lines and 50 mega bytes. Value provided as integer,
 -rotateByTime  rotation done by clock of process run time. Default is clock,
 -timeLimit     time limit in seconds. Default is 86400 (1 day),
 -startup       rotate on startup. By default doesn&#39;t rotate on startup,
 -identifier    log process identifier to be used by administrator/scripts to locate split logger running in background,
 -flush         do not buffer output. flush each line. Default is to use buffering,
 -verbose       debug mode,

 -help          this help,
 -man           shows longer manual.

 You can use first letters of option names to make command line shorter.</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Forwards stdin data stream to a log file and maintain rotation rules. Rotated files get date/time signature at the end of the file name, but before extension. In case of name conflict (too fast log generation), date/time is extended by unique sequence. Uses internal rotation rules and writes data synchronously just after data reception. Does not require external tool as logrotate, and does not react on HUP signal.</p>

<h1 id="EXAMPLES">EXAMPLES</h1>

<dl>

<dt id="Rotate-by-bytes"><b>Rotate by bytes</b></dt>
<dd>

<pre><code> seq 1 100 2&gt;&amp;1 | perl logsplitter.pl -n rotate-seq -l 30

 ls -lh rotate-s*
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-1.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-2.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-3.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-4.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-5.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-6.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-7.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222-8.log
 -rw-r--r--  1 user  staff    30B Jan 21 16:52 rotate-seq-2015-01-21-165222.log
 -rw-r--r--  1 user  staff    22B Jan 21 16:52 rotate-seq.log</code></pre>

</dd>
<dt id="Rotate-by-lines"><b>Rotate by lines</b></dt>
<dd>

<pre><code> seq 1 100 2&gt;&amp;1 | perl logsplitter.pl -n rotate-seq -rotateBySize lines -l 10

 wc -l rotate-seq*
      10 rotate-seq-2015-01-21-170025-1.log
      10 rotate-seq-2015-01-21-170025-2.log
      10 rotate-seq-2015-01-21-170025-3.log
      10 rotate-seq-2015-01-21-170025-4.log
      10 rotate-seq-2015-01-21-170025-5.log
      10 rotate-seq-2015-01-21-170025-6.log
      10 rotate-seq-2015-01-21-170025-7.log
      10 rotate-seq-2015-01-21-170025-8.log
      10 rotate-seq-2015-01-21-170025-9.log
      10 rotate-seq-2015-01-21-170025.log
       0 rotate-seq.log
     100 total</code></pre>

</dd>
<dt id="Rotate-by-process-run-time"><b>Rotate by process run time</b></dt>
<dd>

<pre><code> # waiting for proper time x1s
 while [ $(date +%S | cut -b2) -ne 1 ]; do sleep 1; echo -n .; done; echo
 for cnt in $(seq 1 100); do echo $cnt; sleep 0.1; done 2&gt;&amp;1 | perl logsplitter.pl -n rotate-seq -rotateByTime run -timeLimit 5 -flush

 ls -lhTU *.log
 -rw-r--r--  1 user  staff   123B Feb 17 16:34:11 2015 rotate-seq-2015-02-17-163416.log &lt;- lapsed 5 seconds 
 -rw-r--r--  1 user  staff   147B Feb 17 16:34:16 2015 rotate-seq-2015-02-17-163421.log &lt;- lapsed 5 seconds
 -rw-r--r--  1 user  staff    22B Feb 17 16:34:21 2015 rotate-seq.log</code></pre>

</dd>
<dt id="Rotate-by-clock-time"><b>Rotate by clock time</b></dt>
<dd>

<pre><code> for cnt in $(seq 1 100); do echo $cnt; sleep 0.1; done 2&gt;&amp;1 | perl logsplitter.pl -n rotate-seq -rotateByTime clock -timeLimit 5 

 wc -l rotate-seq*
      32 rotate-seq-2015-02-17-161715.log        &lt;- wall clock passed 5 seconds window
      48 rotate-seq-2015-02-17-161720.log        &lt;- wall clock passed 5 seconds window
      20 rotate-seq.log
     100 total</code></pre>

</dd>
<dt id="Rotate-by-lines-and-process-run-time"><b>Rotate by lines and process run time</b></dt>
<dd>

<pre><code> for cnt in $(seq 1 100); do echo $cnt; sleep 0.1; done 2&gt;&amp;1 | perl logsplitter.pl -n rotate-seq -rotateByTime run -timeLimit 5 -rotateBy lines -limit 40

 wc -l *.log
      40 rotate-seq-2015-02-17-160626.log       &lt;- 40 lines limit
       1 rotate-seq-2015-02-17-160627.log       &lt;- lapsed 5 seconds
      40 rotate-seq-2015-02-17-160631.log       &lt;- 40 lines limit
       8 rotate-seq-2015-02-17-160632.log       &lt;- lapsed 5 seconds
      11 rotate-seq.log
     100 total</code></pre>

</dd>
<dt id="Rotate-file-explicitly-written-by-a-program"><b>Rotate file explicitly written by a program</b></dt>
<dd>

<pre><code> mkfifo /tmp/logpipe
 tail -c +1 -f /tmp/logpipe | perl logsplitter.pl -n rotate-seq -rotateBySize lines -l 10 -i test001-rotate-seq &amp;
 seq 1 100 2&gt;&amp;1 &gt;/tmp/logpipe

 wc -l rotate-seq*
      10 rotate-seq-2015-01-22-110927-1.log
      10 rotate-seq-2015-01-22-110927-2.log
      10 rotate-seq-2015-01-22-110927-3.log
      10 rotate-seq-2015-01-22-110927-4.log
      10 rotate-seq-2015-01-22-110927-5.log
      10 rotate-seq-2015-01-22-110927-6.log
      10 rotate-seq-2015-01-22-110927-7.log
      10 rotate-seq-2015-01-22-110927-8.log
      10 rotate-seq-2015-01-22-110927-9.log
      10 rotate-seq-2015-01-22-110927.log
       0 rotate-seq.log
     100 total</code></pre>

</dd>
<dt id="Identify-PID-of-background-logsplitter-process"><b>Identify PID of background logsplitter process</b></dt>
<dd>

<pre><code> ps -f | grep &quot;test001-rotate-seq&quot; | grep -v grep
 501  8553   534   0 11:32AM ttys002    0:00.07 perl logsplitter.pl -n rotate-seq -r lines -l 10 -i test001-rotate-seq

 Note that above example is from OSX. Parameters of ps command and its output varies on different operating systems.</code></pre>

</dd>
</dl>

<h1 id="PERFORMANCE">PERFORMANCE</h1>

<p>log splitter was verified to work on three levels of speed: (1) unbuffered write, read from stdin: 100MB/s, (2) buffered write (-f option), read from stdin: 30MB/s, (3) unbuffered write, read from fifo pipe: 10MB/s. Each level of measured speed seems enough for logging purposes.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Ryszard Styczynski &lt;ryszard.styczynski@oracle.com&gt; &lt;http://snailsinnoblesoftware.blogspot.com&gt;</p>

<p>January 2015, version 0.1</p>


</body>

</html>


